# -*- coding: utf-8 -*-
"""BoundingBox.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-bowTpu0-HeD5UkMoByTG0vJRbqV3Z58

## Augment Bounding Boxes

imgaug has native support for bounding boxes and their augmentation. They are represented via their ** top-left and bottom-right corner** coordinates, both as absolute values and with sub-pixel accuracy.

In imgaug, bounding boxes are only affected by augmenters changing the geometry of images. This is the case for e.g. horizontal flips or affine transformations. They are not affected by other methods, such as gaussian noise.

Two classes are provided for bounding box augmentation in imgaug, listed in the following sections.

**API: BoundingBox**

imgaug.augmentables.bbs.BoundingBox(x1, y1, x2, y2, label=None): Container for a single bounding box, defined based on its top-left and bottom-right corners, each given as x- and y- pixel coordinates (floats, i.e. sub-pixel accurate).

Important properties offered by BoundingBox are: .x1, .y1, .x2, .y2, .height, .width, .area, .center_x, .center_y.
Important methods offered by BoundingBox are:
project(from_shape, to_shape): Projects the bounding box coordinates from one image shape to another.
extend([all_sides], [top], [right], [bottom], [left]): Increases the size of the bounding boxes by pixel values along given sides.
intersection(other, [default]): Returns the intersection bounding box of this bounding box and another one.
union(other): Analogous to intersection(), returns the union.
iou(other): Computes the IoU of this bounding box and another one.
is_fully_within_image(image): Determines whether all bounding box coordinates are inside the image plane.
is_partly_within_image(image): Determines whether at least parts of the bounding box are inside the image plane.
clip_out_of_image(image): Clips off all parts of the bounding box that are outside of the image plane.
shift([x], [y]): Moves the bounding box.
draw_on_image(image, [color], [alpha], [size], [copy], [raise_if_out_of_image]): Draws the bounding box and its label on an image.
draw_label_on_image(image, [color], [color_text], [color_bg], [alpha], [size], [size_text], [height], [copy], [raise_if_out_of_image]): Draws only a rectangle containing the label (text) on an image (above the bounding box).
draw_box_on_image(image, [color], [alpha], [size], [copy], [raise_if_out_of_image): Draws only the box of the bounding box on an image.
extract_from_image(image, [pad], [pad_max], [prevent_zero_size]): Extracts the pixels contained in a bounding box from an image.

**API: BoundingBoxesOnImage**

imgaug.augmentables.bbs.BoundingBoxesOnImage(bounding_boxes, shape): Container for a list of bounding boxes placed on an image. The shape argument denotes the shape of the image on which the bounding boxes are placed. It is required to make sure that augmentations based on the image size are aligned between the image and the bounding boxes placed on it (e.g. cropping).

Important methods offered by BoundingBoxesOnImage are:
on(image): Projects the bounding box(es) onto another image.
from_xyxy_array(xyxy, shape): Creates a BoundingBoxesOnImage instance from an (N,4) numpy array.
to_xyxy_array([dtype]): Converts the instance to an (N,4) numpy array.
draw_on_image([color], [alpha], [size], [copy], [raise_if_out_of_image]): Draws all bounding boxes and their labels onto an image.
remove_out_of_image([fully], [partly]): Removes bounding box that are fully or at least partially outside of the image plane.
clip_out_of_image(): Calls clip_out_of_image() on all bounding boxes.
shift([x], [y]): Calls shift() on all bounding boxes.
"""

# Commented out IPython magic to ensure Python compatibility.
import imageio
import imgaug as ia
from imgaug.augmentables.bbs import BoundingBox, BoundingBoxesOnImage
# %matplotlib inline
ia.seed(1)

image = imageio.imread("https://upload.wikimedia.org/wikipedia/commons/8/8e/Yellow-headed_caracara_%28Milvago_chimachima%29_on_capybara_%28Hydrochoeris_hydrochaeris%29.JPG")
image = ia.imresize_single_image(image, (298, 447)) #altera o tamanho da imagem

bbs = BoundingBoxesOnImage([
    BoundingBox(x1=0.2*447, x2=0.85*447, y1=0.3*298, y2=0.95*298),
    BoundingBox(x1=0.4*447, x2=0.65*447, y1=0.1*298, y2=0.4*298)
], shape=image.shape)

ia.imshow(bbs.draw_on_image(image, size=2))

#Adiciona os filtros com a imagem com bb 
from imgaug import augmenters as iaa 
ia.seed(1)

seq = iaa.Sequential([
    iaa.GammaContrast(1.5),
    iaa.Affine(translate_percent={"x": 0.1}, scale=0.8)
])

image_aug, bbs_aug = seq(image=image, bounding_boxes=bbs)

ia.imshow(bbs_aug.draw_on_image(image_aug, size=2))

image_aug, bbs_aug = iaa.Affine(rotate=45)(image=image, bounding_boxes=bbs) #rotacionando a imagem e a bb junto
ia.imshow(bbs_aug.draw_on_image(image_aug))

import numpy as np
import matplotlib.pyplot as plt

# highlight the area of each bounding box
image_points = np.copy(image)
colors = [(0, 255, 0), (128, 128, 255)] #azul e verde
for bb, color in zip(bbs.bounding_boxes, colors):
    image_points[bb.y1_int:bb.y2_int:4, bb.x1_int:bb.x2_int:4] = color

# rotate the image with the highlighted bounding box areas
rot = iaa.Affine(rotate=45)
image_points_aug, bbs_aug = rot(image=image_points, bounding_boxes=bbs)

# visualize
side_by_side = np.hstack([
    bbs.draw_on_image(image_points, size=2),
    bbs_aug.draw_on_image(image_points_aug, size=2)
])
fig, ax = plt.subplots(figsize=(20, 20))
ax.imshow(side_by_side)

# Drawing bounding boxes on images
image_bbs = np.copy(image)
image_bbs = bbs.bounding_boxes[0].draw_on_image(image_bbs, color=[255, 0, 0], size=3)
image_bbs = bbs.bounding_boxes[1].draw_on_image(image_bbs, color=[0, 255, 0], size=10, alpha=0.5)
ia.imshow(image_bbs)

# labels to the bounding boxes
bbs_labeled = bbs.deepcopy()
bbs_labeled[0].label = "approximately a pig"
bbs_labeled[1].label = "bird"

image_bbs = bbs_labeled.draw_on_image(image, size=2)

ia.imshow(image_bbs)

#extracting image content
bird = bbs.bounding_boxes[1].extract_from_image(image)
ia.imshow(bird)

# use extend to extract a larger area
bird = bbs.bounding_boxes[1].extend(all_sides=10, left=100).extract_from_image(image)
ia.imshow(bird)

# shifting the bb to extract partially outside the image 
bb = bbs.bounding_boxes[1].shift(x=200)
ia.imshow(bb.draw_on_image(image, size=2))
ia.imshow(bb.extract_from_image(image))

#Projecting bounding boxes onto other images
# we limit the example here to the bounding box of the bird
bb_bird = bbs.bounding_boxes[1]
bbsoi_bird = ia.BoundingBoxesOnImage([bbs.bounding_boxes[1]], shape=image.shape)

# lets resize the original image to twice its width
image_larger = ia.imresize_single_image(image, (1.0, 2.0))

# we draw what would happen without any change to the bounding box
print("BoundingBox without changes:")
ia.imshow(bb_bird.draw_on_image(image_larger, size=3))

# now the change it using project()
print("BoundingBox with project(from, to):")
ia.imshow(bb_bird.project(from_shape=image.shape, to_shape=image_larger.shape)\
                 .draw_on_image(image_larger, size=3))

# and now we do the same two steps for BoundingBoxesOnImage, though here the method is called .on()
print("BoundingBoxesOnImage without changes:")
ia.imshow(bbsoi_bird.draw_on_image(image_larger, size=3))

print("BoundingBoxesOnImage with on(shape):")
ia.imshow(bbsoi_bird.on(image_larger.shape).draw_on_image(image_larger, size=3))